Sorter adapters
===============

Sorter adapters are the main reason for using sorter function objects instead
of regular functions. A *sorter adapter* is a class template that takes another
`Sorter` template parameter and alters its behavior. The resulting class can be
used as a regular sorter.

`counting_sorter`
-----------------

```cpp
#include <cpp-sort/sorters/counting_sorter.h>
```

Unlike other sorters, `counting_sorter::operator()` does not return `void` but
the number of comparisons that have been needed to sort the iterable. It will
adapt the comparison functor so that it can count the number of comparisons
made by any other sorter with a reasonable implementation. Generally speaking,
the number of comparisons of a sort can be used as an heuristic in hybrid sorts
and may be constitute interesting information nevertheless.

The actual counter type can be configured with the template parameter `CountType`,
which defaults to `std::size_t` if not specified.

```cpp
template<
    typename Sorter,
    typename CountType = std::size_t
>
struct counting_sorter;
```

`self_sorter`
-------------

```cpp
#include <cpp-sort/sorters/self_sorter.h>
```

The name is not the best in thee World, but this adapter takes a sorter and, if
the object to be sorted has a `sort` method, it is used to sort the object.
Otherwise, the adapted sorter is used instead to sort the collection.

This sorter adapter allows to support out-of-the-box sorting for `std::list` and
`std::forward_list` as well as other user-defined classes that implement a `sort`
method.

```cpp
template<typename Sorter>
struct self_sorter;
```

`small_array_sorter`
--------------------

```cpp
#include <cpp-sort/sorters/small_array_sorter.h>
```

This sorter adapter comes into two flavors:

```cpp
template<typename Sorter>
struct small_array_sorter<Sorter>;
```

This specialization takes a sorter and uses it to sort the collections it
receives. However, if the collection is an `std::array` or a fixed-size C
array, it replaces the `Sorter` sort by special algorithms designed to sort
small arrays of fixed size.

The specific sorting algorithms used by `small_array_sorter` mostly correspond
to [sorting networks](https://en.wikipedia.org/wiki/Sorting_network) of a given
size. There are specialized algorithms for the sizes 0 to 32. The following table
documents the number of comparisons and the number of swaps made by every
algorithm:

Size | comparisons | swaps
---- | ----------- | -----
0 | 0 | 0
1 | 0 | 0
2 | 1 | ≤ 1
3 | 2-3 | < 2
4 | 5 | ≤ 5
5 | 9 | ≤ 9
6 | 12 | ≤ 12
7 | 16 | ≤ 16
8 | 19 | ≤ 19
9 | 25 | ≤ 25
10 | 29 | ≤ 29
11 | 35 | ≤ 35
12 | 39 | ≤ 39
13 | 45 | ≤ 45
14 | 51 | ≤ 51
15 | 56 | ≤ 56
16 | 60 | ≤ 60
17 | 74 | ≤ 74
18 | 82 | ≤ 82
19 | 91 | ≤ 91
20 | 97 | ≤ 97
21 | 107 | ≤ 107
22 | 114 | ≤ 114
23 | 122 | ≤ 122
24 | 127 | ≤ 127
25 | 138 | ≤ 138
26 | 146 | ≤ 146
27 | 155 | ≤ 155
28 | 161 | ≤ 161
29 | 171 | ≤ 171
30 | 178 | ≤ 178
31 | 186 | ≤ 186
32 | 191 | ≤ 191

The code for most of these algorithms has been generated using the `SWAP` macros
generated by http://pages.ripco.net/~jgamble/nw.html with the "Best" algorithm (as
described on the site) for inputs inferior or equal to 16, and Batcher's Merge-Exchange
algorithm otherwise. Following is the full list of resources used to write the
different algorithms:

* [Algorithm 3](https://github.com/llvm-mirror/libcxx/blob/master/include/algorithm#L3602)
* [Other algorithms](http://pages.ripco.net/~jgamble/nw.html)

There is another specialization of `small_array_sorter` which takes a `Sorter` and
an `std::index_sequence`:

```cpp
template<
    typename Sorter,
    std::size_t... Indices
>
struct small_array_sorter<Sorter, std::index_sequence<Indices...>>;
```

This version of the sorter adapter only uses the specialized sorting algorithms
for fixed-size arrays if the size is contained in `Indices`, and falls back to
`Sorter` in every other case. The main advantage is that it allows to use the class
[`std::make_index_sequence`](http://en.cppreference.com/w/cpp/utility/integer_sequence)
to generate the indices and pick the specialized algorithms for the smallest values
of N, which tend to be the most optimized ones.
